<file path="App.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Styling;          // Required for RequestedThemeVariant, Application.Styles
using Avalonia.Themes.Fluent;    // Required for FluentTheme
using Dottle.Services;
using Dottle.ViewModels;
using Dottle.Views;
// using System; // Check if needed - likely not directly

namespace Dottle;

public class App : Application
{
    private readonly EncryptionService _encryptionService;
    private readonly JournalService _journalService;

    public App()
    {
        _encryptionService = new EncryptionService();
        _journalService = new JournalService(_encryptionService);
    }

    public override void OnFrameworkInitializationCompleted()
    {
        // Load the theme explicitly in C#
        Styles.Add(new FluentTheme()); // Add FluentTheme instance

        // Set the desired theme variant AFTER adding the theme
        RequestedThemeVariant = ThemeVariant.Dark;

        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var loginViewModel = new LoginViewModel();
            var loginView = new LoginView
            {
                DataContext = loginViewModel
            };

            var mainWindow = new Window
            {
                Title = "Dottle - Login",
                Content = loginView,
                Width = 400,
                Height = 300,
                WindowStartupLocation = WindowStartupLocation.CenterScreen,
                CanResize = false,
                SystemDecorations = SystemDecorations.Full
            };

            loginViewModel.LoginSuccessful += (sender, password) =>
            {
                var mainViewModel = new MainViewModel(_journalService, password);
                var mainView = new MainView
                {
                    DataContext = mainViewModel
                };

                mainWindow.Content = mainView;
                mainWindow.Title = "Dottle Journal";
                mainWindow.Width = 900;
                mainWindow.Height = 650;
                mainWindow.MinWidth = 600;
                mainWindow.MinHeight = 400;
                mainWindow.CanResize = true;
                mainWindow.WindowStartupLocation = WindowStartupLocation.CenterScreen;
            };

            loginViewModel.LoginFailed += (sender, args) =>
            {
                // Optional feedback
            };

            desktop.MainWindow = mainWindow;
        }

        base.OnFrameworkInitializationCompleted();
    }
}
</file>

<file path="Program.cs">
using Avalonia;

namespace Dottle;

internal sealed class Program
{
    [STAThread]
    public static void Main(string[] args) => BuildAvaloniaApp()
    .StartWithClassicDesktopLifetime(args);

    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace();
    // Commented out UseReactiveUI() as it's not strictly needed for this approach
    // .UseReactiveUI();
}
</file>

<file path="ViewLocator.cs">
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Dottle.ViewModels;

namespace Dottle
{
    public class ViewLocator : IDataTemplate
    {

        public Control? Build(object? param)
        {
            if (param is null)
                return null;

            var name = param.GetType().FullName!.Replace("ViewModel", "View", StringComparison.Ordinal);
            var type = Type.GetType(name);

            if (type != null)
            {
                return (Control)Activator.CreateInstance(type)!;
            }

            return new TextBlock { Text = "Not Found: " + name };
        }

        public bool Match(object? data)
        {
            return data is ViewModelBase;
        }
    }
}
</file>

<file path="Converters\BindingConverters.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using Avalonia.Data.Converters;
using Dottle.ViewModels; // Assuming enums are in this namespace

namespace Dottle.Converters;

/// <summary>
/// Converts an Enum value to true if it matches the converter parameter, otherwise false.
/// Used for binding RadioButton IsChecked to an Enum property.
/// </summary>
public class EnumToBooleanConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value == null || parameter == null)
            return false;

        // Check if the enum value matches the parameter (which should be the enum value this radio button represents)
        return value.Equals(parameter);
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        // If this radio button is checked (value is true), return its corresponding enum value (parameter)
        if (value is true)
            return parameter;

        // Otherwise, do nothing (Avalonia handles unchecking others in the group)
        return Avalonia.Data.BindingOperations.DoNothing;
    }
}

/// <summary>
/// Converts an Enum value to true (Visible) if it matches the converter parameter, otherwise false (Collapsed).
/// </summary>
public class EnumToVisibilityConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value == null || parameter == null)
            return false; // Default to not visible if values are null

        // Check if the enum value matches the parameter (which should be the enum value that triggers visibility)
        return value.Equals(parameter);
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        // Conversion back is not needed for visibility
        throw new NotImplementedException();
    }
}


/// <summary>
/// Multi-value converter to determine if the "Export as Single File" checkbox should be enabled.
/// Enabled only if CanSelectFolder is true AND SelectedExportFormat is FullText.
/// Expects two bindings: CanSelectFolder (bool) and SelectedExportFormat (ExportFormatType).
/// </summary>
public class EnableSingleFileExportConverter : IMultiValueConverter
{
    public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
    {
        if (values?.Count == 2 &&
            values[0] is bool canSelectFolder &&
            values[1] is ExportFormatType selectedFormat)
        {
            return canSelectFolder && selectedFormat == ExportFormatType.FullText;
        }
        return false; // Default to disabled if bindings aren't ready or types mismatch
    }

    // ConvertBack is not needed for IsEnabled
    // public object[]? ConvertBack(object? value, Type[] targetTypes, object? parameter, CultureInfo culture)
    // {
    //     throw new NotImplementedException();
    // }
}
</file>

<file path="Models\JournalEntry.cs">
namespace Dottle.Models;

public class JournalEntry(string fileName, DateTime date)
{
    public string FileName { get; } = fileName;
    public DateTime Date { get; } = date;
    public string DisplayName { get; } = Path.GetFileNameWithoutExtension(fileName);
}
</file>

<file path="Services\EncryptionService.cs">
using System.Security.Cryptography;
using System.Text;

namespace Dottle.Services;

public class EncryptionService
{
    private const int KeySize = 256; // AES key size in bits
    private const int NonceSize = 12; // AES-GCM nonce size in bytes (96 bits)
    private const int TagSize = 16; // AES-GCM auth tag size in bytes (128 bits)
    private const int SaltSize = 16; // PBKDF2 salt size in bytes
    private const int Iterations = 350000; // PBKDF2 iteration count
    private static readonly HashAlgorithmName HashAlgorithm = HashAlgorithmName.SHA512;

    public byte[] Encrypt(string plainText, string password)
    {
        byte[] salt = RandomNumberGenerator.GetBytes(SaltSize);
        byte[] key = Rfc2898DeriveBytes.Pbkdf2(
            Encoding.UTF8.GetBytes(password),
            salt,
            Iterations,
            HashAlgorithm,
            KeySize / 8);

        byte[] nonce = RandomNumberGenerator.GetBytes(NonceSize);
        byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
        byte[] cipherText = new byte[plainBytes.Length];
        byte[] tag = new byte[TagSize];

        using var aesGcm = new AesGcm(key, TagSize);
        aesGcm.Encrypt(nonce, plainBytes, cipherText, tag);

        // Combine salt, nonce, tag, and ciphertext for storage
        // Format: [Salt (16 bytes)][Nonce (12 bytes)][Tag (16 bytes)][Ciphertext (variable)]
        byte[] encryptedData = new byte[SaltSize + NonceSize + TagSize + cipherText.Length];
        Buffer.BlockCopy(salt, 0, encryptedData, 0, SaltSize);
        Buffer.BlockCopy(nonce, 0, encryptedData, SaltSize, NonceSize);
        Buffer.BlockCopy(tag, 0, encryptedData, SaltSize + NonceSize, TagSize);
        Buffer.BlockCopy(cipherText, 0, encryptedData, SaltSize + NonceSize + TagSize, cipherText.Length);

        // Securely clear sensitive byte arrays
        Array.Clear(key, 0, key.Length);
        Array.Clear(plainBytes, 0, plainBytes.Length);

        return encryptedData;
    }

    public string? Decrypt(byte[] encryptedData, string password)
    {
        if (encryptedData == null || encryptedData.Length < SaltSize + NonceSize + TagSize)
        {
            // Data is too short to contain required parts
            return null;
        }

        try
        {
            byte[] salt = new byte[SaltSize];
            Buffer.BlockCopy(encryptedData, 0, salt, 0, SaltSize);

            byte[] key = Rfc2898DeriveBytes.Pbkdf2(
                Encoding.UTF8.GetBytes(password),
                salt,
                Iterations,
                HashAlgorithm,
                KeySize / 8);

            byte[] nonce = new byte[NonceSize];
            Buffer.BlockCopy(encryptedData, SaltSize, nonce, 0, NonceSize);

            byte[] tag = new byte[TagSize];
            Buffer.BlockCopy(encryptedData, SaltSize + NonceSize, tag, 0, TagSize);

            int cipherTextLength = encryptedData.Length - SaltSize - NonceSize - TagSize;
            byte[] cipherText = new byte[cipherTextLength];
            Buffer.BlockCopy(encryptedData, SaltSize + NonceSize + TagSize, cipherText, 0, cipherTextLength);

            byte[] plainBytes = new byte[cipherTextLength];

            using var aesGcm = new AesGcm(key, TagSize);
            aesGcm.Decrypt(nonce, cipherText, tag, plainBytes);

            // Securely clear sensitive byte arrays
            Array.Clear(key, 0, key.Length);
            Array.Clear(cipherText, 0, cipherText.Length);

            return Encoding.UTF8.GetString(plainBytes);
        }
        catch (CryptographicException)
        {
            // Decryption failed - likely wrong password or corrupted data
            return null;
        }
        catch (Exception)
        {
            // Handle other potential exceptions during decryption
            return null;
        }
    }
}
</file>

<file path="Services\JournalService.cs">
using System.Globalization;
using Dottle.Models;
using Dottle.Utils;

namespace Dottle.Services;

public class JournalService
{
    private readonly EncryptionService _encryptionService;
    private readonly string _journalDirectory;
    private static readonly List<string> Moods = ["üå©Ô∏è", "üåßÔ∏è", "üå•Ô∏è", "‚òÄÔ∏è", "üåà"];

    public JournalService(EncryptionService encryptionService)
    {
        _encryptionService = encryptionService;
        string? assemblyLocation = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
        if (string.IsNullOrEmpty(assemblyLocation))
        {
            assemblyLocation = Environment.CurrentDirectory;
        }
        _journalDirectory = Path.Combine(assemblyLocation, "Journals");

        Directory.CreateDirectory(_journalDirectory);
    }

    public IEnumerable<JournalEntry> GetJournalEntries()
    {
        var journalEntries = new List<JournalEntry>();
        var files = Directory.EnumerateFiles(_journalDirectory, "*.txt");
        int currentPersianYear = PersianCalendarHelper.GetPersianYear(DateTime.Now);

        foreach (var file in files)
        {
            string fileName = Path.GetFileNameWithoutExtension(file);
            if (PersianCalendarHelper.TryParsePersianDateString(fileName, out DateTime date))
            {
                // Filter for the current Persian year
                if (PersianCalendarHelper.GetPersianYear(date) == currentPersianYear)
                {
                    journalEntries.Add(new JournalEntry(Path.GetFileName(file), date));
                }
            }
        }

        // Order by date descending within the current year
        return journalEntries.OrderByDescending(je => je.Date);
    }

    // New method to get all entries without year filtering
    public IEnumerable<JournalEntry> GetAllJournalEntries()
    {
        var journalEntries = new List<JournalEntry>();
        var files = Directory.EnumerateFiles(_journalDirectory, "*.txt");

        foreach (var file in files)
        {
            string fileName = Path.GetFileNameWithoutExtension(file);
            if (PersianCalendarHelper.TryParsePersianDateString(fileName, out DateTime date))
            {
                // No year filter here
                journalEntries.Add(new JournalEntry(Path.GetFileName(file), date));
            }
        }

        // Order all entries by date descending
        return journalEntries.OrderByDescending(je => je.Date);
    }


    public string? ReadJournalContent(string fileName, string password)
    {
        string filePath = Path.Combine(_journalDirectory, fileName);
        if (!File.Exists(filePath))
        {
            return null;
        }

        try
        {
            byte[] encryptedData = File.ReadAllBytes(filePath);
            return _encryptionService.Decrypt(encryptedData, password);
        }
        catch (IOException)
        {
            return null;
        }
        catch (Exception)
        {
            return null;
        }
    }

    public bool SaveJournalContent(string fileName, string content, string password)
    {
        string filePath = Path.Combine(_journalDirectory, fileName);
        try
        {
            byte[] encryptedData = _encryptionService.Encrypt(content, password);
            File.WriteAllBytes(filePath, encryptedData);
            return true;
        }
        catch (IOException)
        {
            return false;
        }
        catch (Exception)
        {
            return false;
        }
    }

    public string? CreateNewJournal(DateTime date, string moodEmoji, string password)
    {
        string dateString = PersianCalendarHelper.GetPersianDateString(date);
        string fileName = $"{dateString}.txt";
        string filePath = Path.Combine(_journalDirectory, fileName);

        if (File.Exists(filePath))
        {
            return null;
        }

        string persianDate = dateString;
        string dayOfWeek = date.ToString("dddd", CultureInfo.InvariantCulture);

        int moodIndex = Moods.IndexOf(moodEmoji);
        string moodNumberString = (moodIndex >= 0) ? (moodIndex + 1).ToString() : "?";

        // Added space between emoji and number
        string templateContent = $"üìÖ {persianDate}  üóìÔ∏è {dayOfWeek}  {moodEmoji} {moodNumberString}{Environment.NewLine}{Environment.NewLine}";

        bool success = SaveJournalContent(fileName, templateContent, password);

        return success ? fileName : null;
    }

    public string GetJournalDirectoryPath()
    {
        return _journalDirectory;
    }

    public bool ChangeEncryptionPassword(string oldPassword, string newPassword)
    {
        var files = Directory.EnumerateFiles(_journalDirectory, "*.txt");
        bool allSucceeded = true;

        foreach (var filePath in files)
        {
            string fileName = Path.GetFileName(filePath);
            try
            {
                byte[] encryptedData = File.ReadAllBytes(filePath);
                string? plainText = _encryptionService.Decrypt(encryptedData, oldPassword);

                if (plainText == null)
                {
                    System.Diagnostics.Debug.WriteLine($"Error: Failed to decrypt {fileName} with the provided old password.");
                    allSucceeded = false;
                    break;
                }

                byte[] newEncryptedData = _encryptionService.Encrypt(plainText, newPassword);
                File.WriteAllBytes(filePath, newEncryptedData);
                System.Diagnostics.Debug.WriteLine($"Successfully re-encrypted {fileName}.");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error processing file {fileName}: {ex.Message}");
                allSucceeded = false;
                break;
            }
        }

        return allSucceeded;
    }
}
</file>

<file path="Utils\PersianCalendarHelper.cs">
using System.Globalization;
using System.Text.RegularExpressions;

namespace Dottle.Utils;

public static partial class PersianCalendarHelper
{
    private static readonly PersianCalendar pc = new();
    private static readonly Regex DateFormatRegex = DateRegex();

    public static string GetCurrentPersianDateString()
    {
        var now = DateTime.Now;
        return GetPersianDateString(now);
    }

    public static string GetPersianDateString(DateTime dt)
    {
        int year = pc.GetYear(dt);
        int month = pc.GetMonth(dt);
        int day = pc.GetDayOfMonth(dt);
        return $"{year:D4}-{month:D2}-{day:D2}";
    }

    public static int GetPersianYear(DateTime dt)
    {
        return pc.GetYear(dt);
    }

    public static int GetPersianMonth(DateTime dt)
    {
        return pc.GetMonth(dt);
    }

    private static readonly string[] PersianMonthNames =
    [
        "", // Index 0 is unused
        "Farvardin", "Ordibehesht", "Khordad",
        "Tir", "Mordad", "Shahrivar",
        "Mehr", "Aban", "Azar",
        "Dey", "Bahman", "Esfand"
    ];

    public static string GetPersianMonthName(int month)
    {
        if (month >= 1 && month <= 12)
        {
            return PersianMonthNames[month];
        }
        return "Invalid Month"; // Or throw an exception
    }

    public static bool TryParsePersianDateString(string dateString, out DateTime result)
    {
        result = DateTime.MinValue;
        var match = DateFormatRegex.Match(dateString);

        if (!match.Success)
        {
            return false;
        }

        if (!int.TryParse(match.Groups["year"].Value, out int year)) return false;
        if (!int.TryParse(match.Groups["month"].Value, out int month)) return false;
        if (!int.TryParse(match.Groups["day"].Value, out int day)) return false;

        try
        {
            // Validate month and day ranges for the given Persian year
            if (month < 1 || month > 12) return false;
            int daysInMonth = pc.GetDaysInMonth(year, month);
            if (day < 1 || day > daysInMonth) return false;

            result = pc.ToDateTime(year, month, day, 0, 0, 0, 0);
            return true;
        }
        catch (ArgumentOutOfRangeException)
        {
            // Invalid date components for Persian calendar
            return false;
        }
    }

    // Regex is generated at compile time in .NET 7+
    [GeneratedRegex(@"^(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})$")]
    private static partial Regex DateRegex();
}
</file>

<file path="ViewModels\ChangePasswordDialogViewModel.cs">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace Dottle.ViewModels;

public partial class ChangePasswordDialogViewModel : ViewModelBase
{
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ConfirmChangeCommand))]
    private string? _oldPassword;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ConfirmChangeCommand))]
    private string? _newPassword;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ConfirmChangeCommand))]
    private string? _confirmNewPassword;

    [ObservableProperty]
    private string? _errorMessage;

    public delegate Task<bool> ChangePasswordDelegate(string oldPassword, string newPassword);

    private readonly ChangePasswordDelegate _changePasswordAction;

    public ChangePasswordDialogViewModel(ChangePasswordDelegate changePasswordAction)
    {
        _changePasswordAction = changePasswordAction;
    }

    private bool CanConfirmChange()
    {
        return !string.IsNullOrEmpty(OldPassword) &&
               !string.IsNullOrEmpty(NewPassword) &&
               NewPassword == ConfirmNewPassword;
    }

    [RelayCommand(CanExecute = nameof(CanConfirmChange))]
    private async Task ConfirmChange()
    {
        ErrorMessage = null;

        if (string.IsNullOrEmpty(NewPassword) || NewPassword != ConfirmNewPassword)
        {
            ErrorMessage = "New passwords do not match or are empty.";
            return; // Prevent closing dialog
        }

        if (NewPassword == OldPassword)
        {
            ErrorMessage = "New password cannot be the same as the old password.";
            return; // Prevent closing dialog
        }

        // The actual password validation and re-encryption is handled
        // by the delegate passed in from MainViewModel.
        // This command primarily validates input fields locally.
        // The dialog will be closed externally if this command completes without setting ErrorMessage.
        await Task.CompletedTask; // Placeholder if no async needed here, but keeps signature consistent
    }
}
</file>

<file path="ViewModels\ExportJournalsDialogViewModel.cs">
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Text;
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Dottle.Models;
using Dottle.Services;
using Dottle.Utils; // Needed for PersianCalendarHelper

namespace Dottle.ViewModels;

// Enum for Export Format Type
public enum ExportFormatType
{
    FullText,
    MoodSummary
}

// Enum for Sort Direction
public enum SortDirection
{
    Ascending,
    Descending
}

public partial class ExportJournalItemViewModel : ViewModelBase
{
    [ObservableProperty]
    private bool _isSelected;

    public JournalEntry Journal { get; }
    public string DisplayName => Journal.DisplayName;
    public string FileName => Journal.FileName;
    public DateTime Date => Journal.Date;

    public ExportJournalItemViewModel(JournalEntry journal)
    {
        Journal = journal;
        _isSelected = true;
    }
}

public partial class ExportJournalsDialogViewModel : ViewModelBase
{
    private readonly JournalService _journalService;
    private readonly string _password;
    private readonly Window? _owner;

    [ObservableProperty]
    private ObservableCollection<ExportJournalItemViewModel> _journalItems = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanExport))]
    [NotifyCanExecuteChangedFor(nameof(ExportCommand))]
    private string? _selectedFolderPath;

    [ObservableProperty]
    private string? _statusMessage;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanSelectFolder))]
    [NotifyPropertyChangedFor(nameof(CanExport))]
    [NotifyCanExecuteChangedFor(nameof(SelectFolderCommand))]
    [NotifyCanExecuteChangedFor(nameof(ExportCommand))]
    private bool _isExporting;

    [ObservableProperty]
    private double _exportProgress;

    [ObservableProperty]
    private bool _exportAsSingleFile = true; // Default to single file for full text

    // New properties for export options
    [ObservableProperty]
    private ExportFormatType _selectedExportFormat = ExportFormatType.FullText;

    [ObservableProperty]
    private SortDirection _selectedSortDirection = SortDirection.Ascending;

    public bool CanSelectFolder => !_isExporting;
    public bool CanExport => !_isExporting && !string.IsNullOrEmpty(SelectedFolderPath) && JournalItems.Any(j => j.IsSelected);

    public ExportJournalsDialogViewModel(JournalService journalService, string password, Window? owner)
    {
        _journalService = journalService;
        _password = password;
        _owner = owner;

        LoadAllJournals();
        UpdateStatus("Ready to export.");
    }

    private void LoadAllJournals()
    {
        foreach (var oldItem in JournalItems)
        {
            oldItem.PropertyChanged -= JournalItem_PropertyChanged;
        }

        try
        {
            var allEntries = _journalService.GetAllJournalEntries();
            var itemViewModels = allEntries
                .OrderByDescending(e => e.Date)
                .Select(entry => new ExportJournalItemViewModel(entry))
                .ToList();

            foreach (var newItem in itemViewModels)
            {
                newItem.PropertyChanged += JournalItem_PropertyChanged;
            }

            JournalItems = new ObservableCollection<ExportJournalItemViewModel>(itemViewModels);
            UpdateStatus($"Loaded {JournalItems.Count} journals.");
        }
        catch (Exception ex)
        {
            UpdateStatus($"Error loading journals: {ex.Message}");
            JournalItems.Clear();
        }

        OnPropertyChanged(nameof(CanExport));
        SelectFolderCommand.NotifyCanExecuteChanged();
        ExportCommand.NotifyCanExecuteChanged();
    }

    private void JournalItem_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(ExportJournalItemViewModel.IsSelected))
        {
            OnPropertyChanged(nameof(CanExport));
            ExportCommand.NotifyCanExecuteChanged();
        }
    }

    [RelayCommand(CanExecute = nameof(CanSelectFolder))]
    private async Task SelectFolder()
    {
        if (_owner == null)
        {
            UpdateStatus("Error: Cannot open folder picker, owner window not available.");
            return;
        }

        var folderPickerOptions = new FolderPickerOpenOptions
        {
            Title = "Select Export Destination Folder",
            AllowMultiple = false
        };

        var result = await _owner.StorageProvider.OpenFolderPickerAsync(folderPickerOptions);

        if (result.Count > 0)
        {
            string? path = result[0].TryGetLocalPath();
            if (!string.IsNullOrEmpty(path))
            {
                SelectedFolderPath = path;
                UpdateStatus($"Selected folder: {SelectedFolderPath}");
            }
            else
            {
                UpdateStatus("Error: Could not get a local path for the selected folder.");
                SelectedFolderPath = null;
            }
        }
        else
        {
            UpdateStatus("Folder selection cancelled.");
        }
    }

    [RelayCommand(CanExecute = nameof(CanExport))]
    private async Task Export()
    {
        if (string.IsNullOrEmpty(SelectedFolderPath) || !Directory.Exists(SelectedFolderPath))
        {
            UpdateStatus("Error: Invalid or non-existent export folder selected.");
            return;
        }

        // Order selected journals by date ascending for single file export consistency
        var selectedJournals = JournalItems
            .Where(j => j.IsSelected)
            .OrderBy(j => j.Date)
            .ToList();

        if (!selectedJournals.Any())
        {
            UpdateStatus("No journals selected for export.");
            return;
        }

        IsExporting = true;
        ExportProgress = 0;
        int exportedCount = 0;
        int failedCount = 0;
        int totalToExport = selectedJournals.Count;

        IsExporting = true;
        ExportProgress = 0;
        UpdateStatus($"Starting export of {totalToExport} journals to {SelectedFolderPath}...");

        try
        {
            switch (SelectedExportFormat)
            {
                case ExportFormatType.FullText:
                    string exportMode = ExportAsSingleFile ? "single file" : "multiple files";
                    UpdateStatus($"Starting Full Text export ({exportMode}) of {totalToExport} journals...");
                    if (ExportAsSingleFile)
                    {
                        await ExportAsSingleFileAsync(selectedJournals, totalToExport, exportedCount, failedCount);
                    }
                    else
                    {
                        await ExportAsMultipleFilesAsync(selectedJournals, totalToExport, exportedCount, failedCount);
                    }
                    break;

                case ExportFormatType.MoodSummary:
                    UpdateStatus($"Starting Mood Summary export of {totalToExport} journals...");
                    await ExportMoodSummaryAsync(selectedJournals, totalToExport, exportedCount, failedCount);
                    break;

                default:
                    UpdateStatus($"Error: Unknown export format selected.");
                    IsExporting = false; // Reset exporting state on error
                    break;
            }
        }
        catch (Exception ex)
        {
            UpdateStatus($"Unhandled error during export: {ex.Message}");
            IsExporting = false; // Ensure exporting state is reset on unhandled exception
            ExportProgress = 0; // Reset progress
        }
        // Note: IsExporting and ExportProgress are now set within each specific export method's finally block
    }


    private async Task ExportAsSingleFileAsync(List<ExportJournalItemViewModel> journals, int totalToExport, int exportedCount, int failedCount)
    {
        var stringBuilder = new StringBuilder();
        string singleFileName = $"Dottle_Export_{DateTime.Now:yyyy-MM-dd_HH-mm-ss}.txt";
        string singleFilePath = Path.Combine(SelectedFolderPath!, singleFileName);

        for (int i = 0; i < totalToExport; i++)
        {
            var journalVm = journals[i];
            ExportProgress = (double)(i + 1) / totalToExport * 100;
            UpdateStatus($"Processing {i + 1}/{totalToExport}: {journalVm.DisplayName}...");

            try
            {
                string? decryptedContent = await Task.Run(() =>
                    _journalService.ReadJournalContent(journalVm.FileName, _password));

                if (decryptedContent != null)
                {
                    // Append content directly
                    stringBuilder.AppendLine(decryptedContent);
                    // Add a single blank line as a separator IF it's not the last entry
                    if (i < totalToExport - 1)
                    {
                        stringBuilder.AppendLine();
                    }
                    exportedCount++;
                }
                else
                {
                    failedCount++;
                    UpdateStatus($"Warning: Failed to read/decrypt {journalVm.DisplayName}. Skipped.");
                    stringBuilder.AppendLine($"--- Skipped: {journalVm.DisplayName} (Failed to decrypt) ---");
                    // Add a single blank line as a separator IF it's not the last entry
                    if (i < totalToExport - 1)
                    {
                        stringBuilder.AppendLine();
                    }
                }
            }
            catch (Exception ex)
            {
                failedCount++;
                UpdateStatus($"Error processing {journalVm.DisplayName}: {ex.Message}. Skipped.");
                stringBuilder.AppendLine($"--- Skipped: {journalVm.DisplayName} (Error: {ex.Message}) ---");
                // Add a single blank line as a separator IF it's not the last entry
                if (i < totalToExport - 1)
                {
                    stringBuilder.AppendLine();
                }
            }
            await Task.Delay(5); // Small delay to allow UI updates
        }

        try
        {
            UpdateStatus($"Writing aggregated content to {singleFileName}...");
            await File.WriteAllTextAsync(singleFilePath, stringBuilder.ToString());
            UpdateStatus($"Export complete. {exportedCount} journals written to {singleFileName}, Failures: {failedCount}.");
        }
        catch (Exception ex)
        {
            UpdateStatus($"Error writing aggregated file {singleFileName}: {ex.Message}");
            // In this case, all content might be lost
        }
        finally
        {
            IsExporting = false;
            ExportProgress = 100;
        }
    }

    private async Task ExportAsMultipleFilesAsync(List<ExportJournalItemViewModel> journals, int totalToExport, int exportedCount, int failedCount)
    {
        for (int i = 0; i < totalToExport; i++)
        {
            var journalVm = journals[i]; // Still ordered by date due to initial sorting
            UpdateStatus($"Exporting {i + 1}/{totalToExport}: {journalVm.DisplayName}...");
            ExportProgress = (double)(i + 1) / totalToExport * 100;

            try
            {
                string? decryptedContent = await Task.Run(() =>
                    _journalService.ReadJournalContent(journalVm.FileName, _password));

                if (decryptedContent != null)
                {
                    // Keep original filename but ensure .txt extension
                    string outputFileName = Path.ChangeExtension(journalVm.FileName, ".txt");
                    string outputPath = Path.Combine(SelectedFolderPath!, outputFileName);

                    // Ensure directory exists (though SelectedFolderPath should)
                    Directory.CreateDirectory(SelectedFolderPath!);

                    await File.WriteAllTextAsync(outputPath, decryptedContent);
                    exportedCount++;
                }
                else
                {
                    failedCount++;
                    UpdateStatus($"Warning: Failed to read/decrypt {journalVm.DisplayName}. Skipped.");
                }
            }
            catch (Exception ex)
            {
                failedCount++;
                UpdateStatus($"Error exporting {journalVm.DisplayName}: {ex.Message}. Skipped.");
            }
            await Task.Delay(10); // Keep small delay
        }

        IsExporting = false;
        ExportProgress = 100;
        UpdateStatus($"Export complete. Exported: {exportedCount}, Failed: {failedCount}.");
    }

    // Helper class for mood summary export
    private class MoodEntry
    {
        public DateTime Date { get; set; }
        public int MoodScore { get; set; }
    }

    private async Task ExportMoodSummaryAsync(List<ExportJournalItemViewModel> journals, int totalToExport, int exportedCount, int failedCount)
    {
        var moodEntries = new List<MoodEntry>();
        string moodSummaryFileName = $"Dottle_MoodSummary_{DateTime.Now:yyyy-MM-dd_HH-mm-ss}.txt";
        string moodSummaryFilePath = Path.Combine(SelectedFolderPath!, moodSummaryFileName);

        for (int i = 0; i < totalToExport; i++)
        {
            var journalVm = journals[i]; // Already ordered by date ascending
            ExportProgress = (double)(i + 1) / totalToExport * 100;
            UpdateStatus($"Processing {i + 1}/{totalToExport}: {journalVm.DisplayName} for mood...");

            try
            {
                string? decryptedContent = await Task.Run(() =>
                    _journalService.ReadJournalContent(journalVm.FileName, _password));

                if (decryptedContent != null)
                {
                    using var reader = new StringReader(decryptedContent);
                    string? firstLine = await reader.ReadLineAsync();

                    if (firstLine != null && int.TryParse(firstLine.Trim(), out int moodScore) && moodScore >= 1 && moodScore <= 5)
                    {
                        moodEntries.Add(new MoodEntry { Date = journalVm.Date, MoodScore = moodScore });
                        exportedCount++;
                    }
                    else
                    {
                        failedCount++;
                        UpdateStatus($"Warning: Could not parse mood score from {journalVm.DisplayName}. Skipped.");
                    }
                }
                else
                {
                    failedCount++;
                    UpdateStatus($"Warning: Failed to read/decrypt {journalVm.DisplayName}. Skipped.");
                }
            }
            catch (Exception ex)
            {
                failedCount++;
                UpdateStatus($"Error processing {journalVm.DisplayName} for mood: {ex.Message}. Skipped.");
            }
            await Task.Delay(5); // Small delay for UI updates
        }

        // Sort the results based on user selection
        var sortedEntries = SelectedSortDirection == SortDirection.Ascending
            ? moodEntries.OrderBy(e => e.Date)
            : moodEntries.OrderByDescending(e => e.Date);

        // Build the final string
        var stringBuilder = new StringBuilder();
        foreach (var entry in sortedEntries)
        {
            string persianDate = PersianCalendarHelper.GetPersianDateString(entry.Date);
            string emoji = GetMoodEmoji(entry.MoodScore);
            stringBuilder.AppendLine($"{persianDate} - {entry.MoodScore} - {emoji}");
        }

        // Write to file
        try
        {
            UpdateStatus($"Writing mood summary to {moodSummaryFileName}...");
            await File.WriteAllTextAsync(moodSummaryFilePath, stringBuilder.ToString());
            UpdateStatus($"Mood Summary export complete. {exportedCount} entries written to {moodSummaryFileName}, Failures: {failedCount}.");
        }
        catch (Exception ex)
        {
            UpdateStatus($"Error writing mood summary file {moodSummaryFileName}: {ex.Message}");
        }
        finally
        {
            IsExporting = false;
            ExportProgress = 100;
        }
    }

    private string GetMoodEmoji(int moodScore)
    {
        return moodScore switch
        {
            1 => "üò≠", // Awful
            2 => "üòû", // Bad
            3 => "üòê", // Okay
            4 => "üòä", // Good
            5 => "ü§©", // Great (Using a different one for 5 as requested üåà might not render everywhere)
            _ => "‚ùì"  // Unknown
        };
    }

    private void UpdateStatus(string message)
    {
        StatusMessage = $"{DateTime.Now:HH:mm:ss} - {message}";
    }

    [RelayCommand] private void Confirm() { /* Logic handled by View closing dialog */ }
    [RelayCommand] private void Cancel() { /* Logic handled by View closing dialog */ }
}
</file>

<file path="ViewModels\JournalGroupViewModel.cs">
using System.Collections.ObjectModel;

namespace Dottle.ViewModels;

public partial class JournalGroupViewModel : ViewModelBase
{
    public int Year { get; }
    public ObservableCollection<JournalMonthGroupViewModel> MonthGroups { get; }

    public JournalGroupViewModel(int year, IEnumerable<JournalMonthGroupViewModel> monthGroups)
    {
        Year = year;
        // Order months descending (e.g., Esfand before Farvardin)
        MonthGroups = new ObservableCollection<JournalMonthGroupViewModel>(monthGroups.OrderByDescending(m => m.Month));
    }

    // Display name for the TreeView
    public string DisplayName => $"{Year} ({MonthGroups.Sum(m => m.Journals.Count)})";
}
</file>

<file path="ViewModels\JournalMonthGroupViewModel.cs">
using System.Collections.ObjectModel;
using Dottle.Utils; // Assuming PersianCalendarHelper is here

namespace Dottle.ViewModels;

public partial class JournalMonthGroupViewModel : ViewModelBase
{
    public int Year { get; }
    public int Month { get; }
    public string MonthName { get; }
    public ObservableCollection<JournalViewModel> Journals { get; }

    public JournalMonthGroupViewModel(int year, int month, IEnumerable<JournalViewModel> journals)
    {
        Year = year;
        Month = month;
        MonthName = PersianCalendarHelper.GetPersianMonthName(month); // Get month name
        Journals = new ObservableCollection<JournalViewModel>(journals.OrderByDescending(j => j.Date));
    }

    // Display name for the TreeView
    public string DisplayName => $"{MonthName} ({Journals.Count})";
}
</file>

<file path="ViewModels\JournalViewModel.cs">
using Dottle.Models;

namespace Dottle.ViewModels;

public class JournalViewModel : ViewModelBase
{
    private readonly JournalEntry _journalEntry;

    public string FileName => _journalEntry.FileName;
    public string DisplayName => _journalEntry.DisplayName;
    public DateTime Date => _journalEntry.Date;

    public JournalViewModel(JournalEntry journalEntry)
    {
        _journalEntry = journalEntry;
    }
}
</file>

<file path="ViewModels\LoginViewModel.cs">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace Dottle.ViewModels;

public partial class LoginViewModel : ViewModelBase
{
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(LoginCommand))]
    private string? _password;

    [ObservableProperty]
    private string? _errorMessage;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(LoginCommand))]
    private bool _isLoggingIn;

    public event EventHandler<string>? LoginSuccessful;
    public event EventHandler? LoginFailed;

    public LoginViewModel()
    {

    }

    private bool CanLogin()
    {
        return !string.IsNullOrEmpty(Password) && !IsLoggingIn;
    }

    [RelayCommand(CanExecute = nameof(CanLogin))]
    private async Task Login()
    {
        IsLoggingIn = true;
        ErrorMessage = null;
        await Task.Delay(150);

        // Simplified check: In a real app, attempt decryption here.
        if (!string.IsNullOrEmpty(Password))
        {
            LoginSuccessful?.Invoke(this, Password);
        }
        else
        {
            ErrorMessage = "Invalid password.";
            LoginFailed?.Invoke(this, EventArgs.Empty);
        }

        IsLoggingIn = false;
    }
}
</file>

<file path="ViewModels\MainViewModel.cs">
using System.Collections.ObjectModel;
using Avalonia.Controls;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Dottle.Services;
using Dottle.Utils;
using Dottle.Views;

namespace Dottle.ViewModels;

public partial class MainViewModel : ViewModelBase
{
    private readonly JournalService _journalService;
    private string _password;

    [ObservableProperty]
    private ObservableCollection<JournalGroupViewModel> _journalGroups = new();

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(IsJournalSelected))]
    [NotifyCanExecuteChangedFor(nameof(SaveJournalCommand))]
    private JournalViewModel? _selectedJournal;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(SaveJournalCommand))]
    private string? _currentJournalContent;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(SaveJournalCommand))]
    private bool _isLoadingContent;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(SaveJournalCommand))]
    private bool _isSavingContent;

    [ObservableProperty]
    private string? _statusBarText;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ChangePasswordCommand))]
    private string? _currentPasswordForChange;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ChangePasswordCommand))]
    private string? _newPassword;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ChangePasswordCommand))]
    private string? _confirmNewPassword;

    [ObservableProperty]
    private string? _changePasswordErrorMessage;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ChangePasswordCommand))]
    private bool _isChangingPassword;

    public Window? OwnerWindow { get; set; }

    public bool IsJournalSelected => SelectedJournal != null;

    public MainViewModel(JournalService journalService, string password)
    {
        _journalService = journalService;
        _password = password;
        LoadJournalList();
        UpdateStatusBar($"Journals loaded. Directory: {_journalService.GetJournalDirectoryPath()}");
    }

    partial void OnSelectedJournalChanged(JournalViewModel? value)
    {
        LoadSelectedJournalContent();
    }

    private void LoadJournalList()
    {
        var entries = _journalService.GetJournalEntries(); // Already filtered by current year
        var viewModels = entries.Select(e => new JournalViewModel(e)).ToList();

        var groups = viewModels
            .GroupBy(jvm => PersianCalendarHelper.GetPersianYear(jvm.Date)) // Group by Year
            .Select(yearGroup =>
            {
                var monthGroups = yearGroup
                    .GroupBy(jvm => PersianCalendarHelper.GetPersianMonth(jvm.Date)) // Group by Month within Year
                    .Select(monthGroup => new JournalMonthGroupViewModel(
                        yearGroup.Key,
                        monthGroup.Key,
                        monthGroup.ToList())) // Create Month Group VM
                    .OrderByDescending(mg => mg.Month); // Order months within the year

                return new JournalGroupViewModel(yearGroup.Key, monthGroups); // Create Year Group VM
            })
            .OrderByDescending(g => g.Year); // Order years

        JournalGroups = new ObservableCollection<JournalGroupViewModel>(groups);

        SelectedJournal = null;
        CurrentJournalContent = string.Empty;
        UpdateStatusBar("Journal list refreshed (Current Year Only).");
    }

    private async void LoadSelectedJournalContent()
    {
        if (SelectedJournal == null)
        {
            CurrentJournalContent = string.Empty;
            return;
        }

        IsLoadingContent = true;
        CurrentJournalContent = string.Empty;
        UpdateStatusBar($"Loading {SelectedJournal.DisplayName}...");
        await Task.Delay(50);

        string? content = await Task.Run(() =>
            _journalService.ReadJournalContent(SelectedJournal.FileName, _password));

        IsLoadingContent = false;

        if (content != null)
        {
            CurrentJournalContent = content;
            UpdateStatusBar($"Loaded {SelectedJournal.DisplayName}.");
        }
        else
        {
            CurrentJournalContent = $"Error: Could not load or decrypt '{SelectedJournal.FileName}'. Check password or file integrity.";
            UpdateStatusBar($"Error loading {SelectedJournal.DisplayName}.");
        }
        SaveJournalCommand.NotifyCanExecuteChanged();
    }

    private bool CanSaveJournal()
    {
        return SelectedJournal != null &&
               CurrentJournalContent != null &&
               !IsLoadingContent &&
               !IsSavingContent;
    }

    [RelayCommand(CanExecute = nameof(CanSaveJournal))]
    private async Task SaveJournal()
    {
        if (SelectedJournal == null || CurrentJournalContent == null) return;

        IsSavingContent = true;
        UpdateStatusBar($"Saving {SelectedJournal.DisplayName}...");
        await Task.Delay(50);

        bool success = await Task.Run(() =>
            _journalService.SaveJournalContent(SelectedJournal.FileName, CurrentJournalContent, _password));

        IsSavingContent = false;

        if (success)
        {
            UpdateStatusBar($"Saved {SelectedJournal.DisplayName} successfully.");
        }
        else
        {
            UpdateStatusBar($"Error: Failed to save {SelectedJournal.DisplayName}.");
        }
        SaveJournalCommand.NotifyCanExecuteChanged();
    }

    [RelayCommand]
    private async Task RequestNewJournalDate()
    {
        if (OwnerWindow == null)
        {
            UpdateStatusBar("Error: Cannot show dialog, owner window not set.");
            return;
        }

        var dialogViewModel = new NewJournalDialogViewModel();
        var dialog = new NewJournalDialog
        {
            DataContext = dialogViewModel
        };

        bool? dialogResult = await dialog.ShowDialog<bool?>(OwnerWindow);

        if (dialogResult == true && dialog.IsConfirmed)
        {
            DateTime selectedDate = dialog.SelectedDate;
            string selectedMood = dialog.SelectedMood; // Get mood from dialog
            string dateString = PersianCalendarHelper.GetPersianDateString(selectedDate);
            UpdateStatusBar($"Creating journal for {dateString} with mood {selectedMood}...");

            // Pass mood to service
            string? newFileName = await Task.Run(() =>
                _journalService.CreateNewJournal(selectedDate, selectedMood, _password));

            if (newFileName != null)
            {
                LoadJournalList();
                var newEntryVm = FindJournalViewModelByFileName(newFileName);
                SelectedJournal = newEntryVm;
                UpdateStatusBar($"Created and selected journal for {dateString}.");
            }
            else
            {
                UpdateStatusBar($"Journal for {dateString} already exists or could not be created.");
                string existingFileName = $"{dateString}.txt";
                var existingEntryVm = FindJournalViewModelByFileName(existingFileName);
                if (existingEntryVm != null && SelectedJournal != existingEntryVm)
                {
                    SelectedJournal = existingEntryVm;
                }
            }
        }
        else
        {
            UpdateStatusBar("New journal creation cancelled.");
        }
    }


    private JournalViewModel? FindJournalViewModelByFileName(string fileName)
    {
        // Search through the new nested structure: Year -> Month -> Journal
        return JournalGroups
            .SelectMany(yearGroup => yearGroup.MonthGroups)
            .SelectMany(monthGroup => monthGroup.Journals)
            .FirstOrDefault(j => j.FileName.Equals(fileName, StringComparison.OrdinalIgnoreCase));
    }

    private void UpdateStatusBar(string message)
    {
        StatusBarText = $"{DateTime.Now:HH:mm:ss} - {message}";
    }

    private bool CanChangePassword()
    {
        return !string.IsNullOrEmpty(CurrentPasswordForChange) &&
               !string.IsNullOrEmpty(NewPassword) &&
               NewPassword == ConfirmNewPassword &&
               NewPassword != CurrentPasswordForChange &&
               !IsChangingPassword;
    }

    [RelayCommand(CanExecute = nameof(CanChangePassword))]
    private async Task ChangePassword()
    {
        ChangePasswordErrorMessage = null;

        if (CurrentPasswordForChange != _password)
        {
            ChangePasswordErrorMessage = "The Current Password provided does not match the active password.";
            UpdateStatusBar("Password change failed: Incorrect current password.");
            return;
        }

        if (string.IsNullOrEmpty(NewPassword) || NewPassword != ConfirmNewPassword)
        {
            ChangePasswordErrorMessage = "New passwords do not match or are empty.";
            UpdateStatusBar("Password change failed: New passwords mismatch or empty.");
            return;
        }
        if (NewPassword == _password)
        {
            ChangePasswordErrorMessage = "New password cannot be the same as the old password.";
            UpdateStatusBar("Password change failed: New password is same as old.");
            return;
        }

        IsChangingPassword = true;
        UpdateStatusBar("Changing password and re-encrypting all journals... Please wait.");
        await Task.Delay(50);

        bool success = await Task.Run(() =>
            _journalService.ChangeEncryptionPassword(_password, NewPassword!));

        IsChangingPassword = false;

        if (success)
        {
            _password = NewPassword!;
            CurrentPasswordForChange = null;
            NewPassword = null;
            ConfirmNewPassword = null;
            ChangePasswordErrorMessage = null;
            UpdateStatusBar("Password changed successfully. All journals re-encrypted.");
            if (SelectedJournal is not null) LoadSelectedJournalContent();
        }
        else
        {
            ChangePasswordErrorMessage = "Critical Error: Failed to re-encrypt one or more journals. Password has NOT been changed.";
            UpdateStatusBar("Error changing password. See error message. Password remains unchanged.");
        }
        ChangePasswordCommand.NotifyCanExecuteChanged();
    }

    [RelayCommand]
    private async Task ShowExportDialog()
    {
        if (OwnerWindow == null)
        {
            UpdateStatusBar("Error: Cannot show export dialog, owner window not set.");
            return;
        }

        UpdateStatusBar("Opening export dialog...");

        try
        {
            // Pass the JournalService, current password, and owner window to the dialog VM
            var exportViewModel = new ExportJournalsDialogViewModel(_journalService, _password, OwnerWindow);
            var exportDialog = new ExportJournalsDialog
            {
                DataContext = exportViewModel
            };

            // Show the dialog modally
            await exportDialog.ShowDialog(OwnerWindow); // We don't need a result back

            UpdateStatusBar("Export dialog closed.");
        }
        catch (Exception ex)
        {
            // Log the exception details if possible
            System.Diagnostics.Debug.WriteLine($"Error showing export dialog: {ex}");
            UpdateStatusBar($"Error: Could not open export dialog. {ex.Message}");
        }
    }
}
</file>

<file path="ViewModels\MainWindowViewModel.cs">
namespace Dottle.ViewModels
{
    public partial class MainWindowViewModel : ViewModelBase
    {
        public string Greeting { get; } = "Welcome to Avalonia!";
    }
}
</file>

<file path="ViewModels\NewJournalDialogViewModel.cs">
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using Dottle.Utils;

namespace Dottle.ViewModels;

public partial class NewJournalDialogViewModel : ViewModelBase
{
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(PersianDateString))]
    [NotifyCanExecuteChangedFor(nameof(ConfirmCommand))]
    private DateTimeOffset? _selectedDate = DateTimeOffset.Now;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(ConfirmCommand))]
    private string? _selectedMoodEmoji;

    [ObservableProperty]
    private string? _errorMessage;

    // Available moods for selection
    public List<string> AvailableMoods { get; } = ["üå©Ô∏è", "üåßÔ∏è", "üå•Ô∏è", "‚òÄÔ∏è", "üåà"];

    public string PersianDateString => SelectedDate.HasValue
        ? PersianCalendarHelper.GetPersianDateString(SelectedDate.Value.Date)
        : "No date selected";

    public DateTime ConfirmedDate { get; private set; }
    public string ConfirmedMoodEmoji { get; private set; } = string.Empty;

    public NewJournalDialogViewModel()
    {
        SelectedDate = DateTimeOffset.Now;
        // Optionally set a default mood, or leave it null to force selection
        // SelectedMoodEmoji = AvailableMoods.FirstOrDefault();
    }

    private bool CanConfirm()
    {
        // Must have both date and mood selected
        return SelectedDate.HasValue && !string.IsNullOrEmpty(SelectedMoodEmoji);
    }

    [RelayCommand(CanExecute = nameof(CanConfirm))]
    private void Confirm()
    {
        ErrorMessage = null;
        if (!SelectedDate.HasValue)
        {
            ErrorMessage = "Please select a date.";
            return;
        }
        if (string.IsNullOrEmpty(SelectedMoodEmoji))
        {
            ErrorMessage = "Please select a mood.";
            return;
        }

        ConfirmedDate = SelectedDate.Value.Date;
        ConfirmedMoodEmoji = SelectedMoodEmoji; // Store confirmed mood

        // Dialog closing handled by View
    }
}
</file>

<file path="ViewModels\ViewModelBase.cs">
using CommunityToolkit.Mvvm.ComponentModel;

namespace Dottle.ViewModels;

public abstract class ViewModelBase : ObservableObject
{
}
</file>

<file path="Views\ChangePasswordDialog.cs">
using System.ComponentModel;
using System.Windows.Input;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Interactivity; // Required for RoutedEventArgs
using Avalonia.Layout;
using Avalonia.Media;
using Dottle.ViewModels;

namespace Dottle.Views;

public sealed class ChangePasswordDialog : Window
{
    private readonly TextBox _oldPasswordBox;
    private readonly TextBox _newPasswordBox;
    private readonly TextBox _confirmPasswordBox;
    private readonly Button _confirmButton;
    private readonly Button _cancelButton;
    private readonly TextBlock _errorMessageTextBlock;

    private ChangePasswordDialogViewModel? _viewModel;
    private ICommand? _confirmCommandInstance;

    public bool IsConfirmed { get; private set; } = false;

    public ChangePasswordDialog()
    {
        Title = "Change Password";
        Width = 400;
        Height = 300; // Adjusted height slightly for typical content
        CanResize = false;
        WindowStartupLocation = WindowStartupLocation.CenterOwner;
        SystemDecorations = SystemDecorations.Full;

        this.DataContextChanged += OnDataContextChangedHandler;

        // --- Controls ---
        _oldPasswordBox = new TextBox { Watermark = "Current Password", PasswordChar = '*', Margin = new Thickness(0, 0, 0, 10) };
        // Corrected Handler: Assign directly to ViewModel property
        _oldPasswordBox.TextChanged += (s, e) => { if (_viewModel != null) _viewModel.OldPassword = _oldPasswordBox.Text; };

        _newPasswordBox = new TextBox { Watermark = "New Password", PasswordChar = '*', Margin = new Thickness(0, 0, 0, 10) };
        // Corrected Handler: Assign directly to ViewModel property
        _newPasswordBox.TextChanged += (s, e) => { if (_viewModel != null) _viewModel.NewPassword = _newPasswordBox.Text; };

        _confirmPasswordBox = new TextBox { Watermark = "Confirm New Password", PasswordChar = '*', Margin = new Thickness(0, 0, 0, 15) };
        // Corrected Handler: Assign directly to ViewModel property
        _confirmPasswordBox.TextChanged += (s, e) => { if (_viewModel != null) _viewModel.ConfirmNewPassword = _confirmPasswordBox.Text; };

        _errorMessageTextBlock = new TextBlock
        {
            Foreground = Brushes.Red,
            HorizontalAlignment = HorizontalAlignment.Center,
            TextWrapping = TextWrapping.Wrap,
            Margin = new Thickness(0, 0, 0, 10),
            MinHeight = 30 // Reserve space
        };

        _confirmButton = new Button { Content = "Confirm Change", IsDefault = true, IsEnabled = false, HorizontalAlignment = HorizontalAlignment.Stretch };
        _confirmButton.Classes.Add("accent");
        _confirmButton.Click += ConfirmButton_Click;

        _cancelButton = new Button { Content = "Cancel", IsCancel = true, HorizontalAlignment = HorizontalAlignment.Stretch };
        _cancelButton.Click += (s, e) => Close(false);

        // --- Layout ---
        var buttonPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            Spacing = 10,
            HorizontalAlignment = HorizontalAlignment.Right, // Align buttons to the right
            Children = { _cancelButton, _confirmButton }
        };

        var mainPanel = new StackPanel
        {
            Margin = new Thickness(20),
            Spacing = 5,
            Children =
            {
                new TextBlock { Text = "Change Journal Encryption Password", FontSize = 16, FontWeight = FontWeight.SemiBold, Margin = new Thickness(0,0,0,15), HorizontalAlignment = HorizontalAlignment.Center },
                _oldPasswordBox,
                _newPasswordBox,
                _confirmPasswordBox,
                _errorMessageTextBlock,
                buttonPanel
            }
        };

        Content = mainPanel;
    }

    private void OnDataContextChangedHandler(object? sender, EventArgs e)
    {
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
        }

        _confirmCommandInstance = null;
        _viewModel = DataContext as ChangePasswordDialogViewModel;

        if (_viewModel != null)
        {
            _viewModel.PropertyChanged += ViewModel_PropertyChanged;
            _confirmCommandInstance = _viewModel.ConfirmChangeCommand;

            UpdateErrorMessage(_viewModel.ErrorMessage);
            UpdateConfirmButtonState();
            // Reset text boxes to reflect ViewModel state if needed (usually starts empty)
            _oldPasswordBox.Text = _viewModel.OldPassword;
            _newPasswordBox.Text = _viewModel.NewPassword;
            _confirmPasswordBox.Text = _viewModel.ConfirmNewPassword;
        }
        else
        {
            UpdateErrorMessage(null);
            UpdateConfirmButtonState();
            _oldPasswordBox.Text = null;
            _newPasswordBox.Text = null;
            _confirmPasswordBox.Text = null;
        }
    }

    private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (_viewModel == null) return;

        switch (e.PropertyName)
        {
            case nameof(ChangePasswordDialogViewModel.ErrorMessage):
                UpdateErrorMessage(_viewModel.ErrorMessage);
                break;
            // These properties trigger CanExecute changes, handled by UpdateConfirmButtonState
            case nameof(ChangePasswordDialogViewModel.OldPassword):
            case nameof(ChangePasswordDialogViewModel.NewPassword):
            case nameof(ChangePasswordDialogViewModel.ConfirmNewPassword):
                UpdateConfirmButtonState();
                break;
        }
    }

    private async void ConfirmButton_Click(object? sender, RoutedEventArgs e)
    {
        if (_confirmCommandInstance?.CanExecute(null) ?? false)
        {
            // Execute the command (which performs local validation)
            if (_confirmCommandInstance is CommunityToolkit.Mvvm.Input.IAsyncRelayCommand asyncCmd)
            {
                await asyncCmd.ExecuteAsync(null);
            }
            else // Fallback for non-async command, though ours is async
            {
                _confirmCommandInstance.Execute(null);
            }

            // Check the ViewModel's error message *after* command execution
            if (string.IsNullOrEmpty(_viewModel?.ErrorMessage))
            {
                IsConfirmed = true;
                Close(true); // Close dialog indicating success
            }
            // If ErrorMessage is set, the dialog stays open, and the error is displayed
        }
    }

    private void UpdateErrorMessage(string? message)
    {
        _errorMessageTextBlock.Text = message ?? string.Empty;
    }

    private void UpdateConfirmButtonState()
    {
        _confirmButton.IsEnabled = _confirmCommandInstance?.CanExecute(null) ?? false;
    }

    protected override void OnClosed(EventArgs e)
    {
        base.OnClosed(e);
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
        }
        _viewModel = null;
        _confirmCommandInstance = null;
    }
}
</file>

<file path="Views\ExportJournalsDialog.cs">
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Data;
using Avalonia.Layout;
using Avalonia.Media;
// using Avalonia.Data.Converters; // No longer needed directly here
using System.Collections.Generic;
using Dottle.ViewModels;
using Dottle.Converters; // Add using for custom converters

namespace Dottle.Views;

public class ExportJournalsDialog : Window
{
    // --- Define Custom Converters as Static Fields ---
    private static readonly EnumToBooleanConverter s_enumToBooleanConverter = new();
    private static readonly EnumToVisibilityConverter s_enumToVisibilityConverter = new();
    private static readonly EnableSingleFileExportConverter s_enableSingleFileExportConverter = new();


    public bool IsConfirmed { get; private set; } = false;

    public ExportJournalsDialog()
    {
        Title = "Export Journals";
        Width = 500;
        Height = 630;
        WindowStartupLocation = WindowStartupLocation.CenterOwner;
        CanResize = false;

        ListBox journalListBox = new()
        {
            Height = 300,
            Margin = new(10),
            ItemTemplate = new FuncDataTemplate<ExportJournalItemViewModel>((vm, ns) =>
                new CheckBox
                {
                    Content = vm.DisplayName,
                    [!CheckBox.IsCheckedProperty] = new Binding(nameof(vm.IsSelected), BindingMode.TwoWay),
                }, supportsRecycling: true),
            [!ItemsControl.ItemsSourceProperty] = new Binding(nameof(ExportJournalsDialogViewModel.JournalItems))
        };

        TextBlock folderPathTextBlock = new()
        {
            Margin = new(10, 0, 0, 0),
            VerticalAlignment = VerticalAlignment.Center,
            [!TextBlock.TextProperty] = new Binding(nameof(ExportJournalsDialogViewModel.SelectedFolderPath)) { FallbackValue = "No folder selected" }
        };

        Button selectFolderButton = new()
        {
            Content = "Select Folder...",
            Margin = new(10, 5, 10, 5),
            HorizontalAlignment = HorizontalAlignment.Left,
            [!Button.CommandProperty] = new Binding(nameof(ExportJournalsDialogViewModel.SelectFolderCommand)),
            [!Button.IsEnabledProperty] = new Binding(nameof(ExportJournalsDialogViewModel.CanSelectFolder))
        };

        DockPanel folderPanel = new()
        {
            Margin = new Thickness(10, 0),
            Children = { selectFolderButton, folderPathTextBlock }
        };
        DockPanel.SetDock(selectFolderButton, Dock.Left);

        // --- Export Format Selection ---
        TextBlock formatLabel = new() { Text = "Export Format:", Margin = new(10, 10, 10, 0) };
        RadioButton fullTextRadio = new()
        {
            Content = "Full Text",
            GroupName = "ExportFormat",
            Margin = new(10, 0, 5, 0),
            IsChecked = true, // Default - Initial state, binding will take over
            CommandParameter = ExportFormatType.FullText
        };
        // Use custom EnumToBooleanConverter
        fullTextRadio.Bind(RadioButton.IsCheckedProperty, new Binding(nameof(ExportJournalsDialogViewModel.SelectedExportFormat), BindingMode.TwoWay)
        {
            Converter = s_enumToBooleanConverter,
            ConverterParameter = ExportFormatType.FullText // Pass the target enum value
        });

        RadioButton moodSummaryRadio = new()
        {
            Content = "Mood Summary",
            GroupName = "ExportFormat",
            Margin = new(5, 0, 10, 0),
            CommandParameter = ExportFormatType.MoodSummary,
        };
        // Use custom EnumToBooleanConverter
        moodSummaryRadio.Bind(RadioButton.IsCheckedProperty, new Binding(nameof(ExportJournalsDialogViewModel.SelectedExportFormat), BindingMode.TwoWay)
        {
            Converter = s_enumToBooleanConverter,
            ConverterParameter = ExportFormatType.MoodSummary // Pass the target enum value
        });
        StackPanel formatPanel = new()
        {
            Orientation = Orientation.Horizontal,
            Margin = new(10, 5, 10, 5),
            Spacing = 5,
            Children = { fullTextRadio, moodSummaryRadio }
        };

        // --- Sort Direction Selection (Visible only for Mood Summary) ---
        TextBlock sortLabel = new() { Text = "Sort Order (Mood Summary):", Margin = new(10, 5, 10, 0) };
        RadioButton ascendingRadio = new()
        {
            Content = "Ascending",
            GroupName = "SortDirection",
            Margin = new(10, 0, 5, 0),
            IsChecked = true, // Default
            CommandParameter = SortDirection.Ascending
        };
        // Use custom EnumToBooleanConverter
        ascendingRadio.Bind(RadioButton.IsCheckedProperty, new Binding(nameof(ExportJournalsDialogViewModel.SelectedSortDirection), BindingMode.TwoWay)
        {
            Converter = s_enumToBooleanConverter,
            ConverterParameter = SortDirection.Ascending // Pass the target enum value
        });

        RadioButton descendingRadio = new()
        {
            Content = "Descending",
            GroupName = "SortDirection",
            Margin = new(5, 0, 10, 0),
            CommandParameter = SortDirection.Descending,
        };
        // Use custom EnumToBooleanConverter
        descendingRadio.Bind(RadioButton.IsCheckedProperty, new Binding(nameof(ExportJournalsDialogViewModel.SelectedSortDirection), BindingMode.TwoWay)
        {
            Converter = s_enumToBooleanConverter,
            ConverterParameter = SortDirection.Descending // Pass the target enum value
        });
        StackPanel sortPanel = new()
        {
            Orientation = Orientation.Horizontal,
            Margin = new(10, 5, 10, 5),
            Spacing = 5,
            Children = { ascendingRadio, descendingRadio },
        };
        // Use custom EnumToVisibilityConverter
        sortPanel.Bind(StackPanel.IsVisibleProperty, new Binding(nameof(ExportJournalsDialogViewModel.SelectedExportFormat))
        {
            Converter = s_enumToVisibilityConverter,
            ConverterParameter = ExportFormatType.MoodSummary // Make visible when format is MoodSummary
        });

        // --- Existing CheckBox ---
        CheckBox exportSingleFileCheckBox = new()
        {
            Content = "Export selected journals into a single file (Full Text only)",
            Margin = new(10, 5, 10, 5), // Adjusted margin
            HorizontalAlignment = HorizontalAlignment.Left
            // Bind IsChecked directly without converter first
        };
        exportSingleFileCheckBox.Bind(CheckBox.IsCheckedProperty, new Binding(nameof(ExportJournalsDialogViewModel.ExportAsSingleFile), BindingMode.TwoWay));

        // Use custom EnableSingleFileExportConverter
        exportSingleFileCheckBox.Bind(CheckBox.IsEnabledProperty, new MultiBinding
        {
            Bindings =
                {
                    new Binding(nameof(ExportJournalsDialogViewModel.CanSelectFolder)),
                    new Binding(nameof(ExportJournalsDialogViewModel.SelectedExportFormat))
                },
            Converter = s_enableSingleFileExportConverter // Use the custom multi-converter
        });

        ProgressBar progressBar = new()
        {
            Margin = new Thickness(10, 5),
            Minimum = 0,
            Maximum = 100,
            [!ProgressBar.ValueProperty] = new Binding(nameof(ExportJournalsDialogViewModel.ExportProgress)),
            [!ProgressBar.IsVisibleProperty] = new Binding(nameof(ExportJournalsDialogViewModel.IsExporting))
        };

        TextBlock statusTextBlock = new()
        {
            Margin = new Thickness(10, 0, 10, 5),
            FontSize = 11,
            TextWrapping = TextWrapping.Wrap,
            [!TextBlock.TextProperty] = new Binding(nameof(ExportJournalsDialogViewModel.StatusMessage))
        };

        Button exportButton = new()
        {
            Content = "Export Selected",
            HorizontalAlignment = HorizontalAlignment.Right,
            Margin = new(5),
            Classes = { "accent" },
            [!Button.CommandProperty] = new Binding(nameof(ExportJournalsDialogViewModel.ExportCommand)),
            [!Button.IsEnabledProperty] = new Binding(nameof(ExportJournalsDialogViewModel.CanExport))
        };

        Button closeButton = new()
        {
            Content = "Close",
            HorizontalAlignment = HorizontalAlignment.Right,
            Margin = new(5)
        };
        closeButton.Click += (s, e) => Close(false);

        StackPanel buttonPanel = new()
        {
            Orientation = Orientation.Horizontal,
            HorizontalAlignment = HorizontalAlignment.Right,
            Margin = new(10),
            Spacing = 5,
            Children = { exportButton, closeButton }
        };

        DockPanel mainPanel = new()
        {
            Children =
            {
                buttonPanel,
                statusTextBlock,
                progressBar,
                exportSingleFileCheckBox, // Checkbox now below sort panel
                sortPanel,                // Sort options
                formatLabel,              // Format label
                formatPanel,              // Format options
                folderPanel,
                journalListBox
            }
        };

        DockPanel.SetDock(buttonPanel, Dock.Bottom);
        DockPanel.SetDock(statusTextBlock, Dock.Bottom);
        DockPanel.SetDock(progressBar, Dock.Bottom);
        DockPanel.SetDock(exportSingleFileCheckBox, Dock.Bottom);
        DockPanel.SetDock(sortPanel, Dock.Bottom);
        DockPanel.SetDock(formatPanel, Dock.Bottom);
        DockPanel.SetDock(formatLabel, Dock.Bottom);
        DockPanel.SetDock(folderPanel, Dock.Bottom);

        Content = mainPanel;

        // Ensure DataContext is set if not done elsewhere (usually in App.xaml or code-behind)
        // this.DataContext = new ExportJournalsDialogViewModel(...); // Assuming instantiation happens elsewhere
    }

    public new void Close(object? result = null)
    {
        base.Close(result);
    }
}
</file>

<file path="Views\LoginView.cs">
using System.ComponentModel; // Required for PropertyChangedEventArgs
using System.Windows.Input; // Required for ICommand
using Avalonia;
using Avalonia.Controls;
using Avalonia.Interactivity; // Required for RoutedEventArgs
using Avalonia.Layout;
using Avalonia.Media;
using Dottle.ViewModels;

namespace Dottle.Views;

public sealed class LoginView : UserControl
{
    private readonly TextBox _passwordTextBox;
    private readonly Button _loginButton;
    private readonly TextBlock _errorMessageTextBlock;
    private readonly ProgressBar _progressBar;

    // Store ViewModel and Command references
    private LoginViewModel? _viewModel;
    private ICommand? _loginCommandInstance;

    public LoginView()
    {
        this.DataContextChanged += OnDataContextChangedHandler;

        // --- Step 1: Create and Configure Controls (NO BINDINGS) ---

        var titleBlock = new TextBlock
        {
            Text = "Dottle Journal",
            HorizontalAlignment = HorizontalAlignment.Center,
            FontSize = 24,
            Margin = new Avalonia.Thickness(0, 0, 0, 20)
        };
        Grid.SetRow(titleBlock, 0);

        _passwordTextBox = new TextBox
        {
            Watermark = "Password",
            PasswordChar = '*', // Use '*' to mask input visually
            Margin = new Avalonia.Thickness(0, 0, 0, 10)
        };
        Grid.SetRow(_passwordTextBox, 1);
        _passwordTextBox.TextChanged += PasswordTextBox_TextChanged; // Manual VM update

        _loginButton = new Button
        {
            Content = "Login",
            HorizontalAlignment = HorizontalAlignment.Stretch,
            Margin = new Avalonia.Thickness(0, 5, 0, 10),
            IsEnabled = false // Start disabled, enabled via UpdateLoginButtonState
        };
        _loginButton.Classes.Add("accent"); // Apply theme accent style
        Grid.SetRow(_loginButton, 2);
        _loginButton.Click += LoginButton_Click; // Manual command execution

        _errorMessageTextBlock = new TextBlock
        {
            Foreground = Brushes.Red, // Error messages in red
            HorizontalAlignment = HorizontalAlignment.Center,
            TextWrapping = TextWrapping.Wrap, // Wrap long messages
            Margin = new Avalonia.Thickness(0, 0, 0, 10)
            // Text set manually via PropertyChanged
        };
        Grid.SetRow(_errorMessageTextBlock, 3);

        _progressBar = new ProgressBar
        {
            MinWidth = 150,
            IsIndeterminate = true, // Show busy state
            HorizontalAlignment = HorizontalAlignment.Center,
            Margin = new Avalonia.Thickness(0, 5),
            IsVisible = false // Start hidden
            // Visibility set manually via PropertyChanged
        };
        Grid.SetRow(_progressBar, 4);

        // --- Step 2: Create Layout Panel and Add Children ---
        var gridLayout = new Grid
        {
            HorizontalAlignment = HorizontalAlignment.Center,
            VerticalAlignment = VerticalAlignment.Center,
            RowDefinitions = new RowDefinitions("Auto,Auto,Auto,Auto,Auto"),
            MaxWidth = 300,
            // Add the created controls to the Grid's children
            Children =
            {
                titleBlock,
                _passwordTextBox,
                _loginButton,
                _errorMessageTextBlock,
                _progressBar
            }
        };

        // --- Step 3: Set Content ---
        Content = gridLayout;
    }

    // Handle ViewModel changes
    private void OnDataContextChangedHandler(object? sender, EventArgs e)
    {
        // Unsubscribe from old ViewModel if exists
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
        }

        _loginCommandInstance = null; // Clear previous command instance
        _viewModel = DataContext as LoginViewModel; // Store new ViewModel

        if (_viewModel != null)
        {
            // Subscribe to new ViewModel's changes
            _viewModel.PropertyChanged += ViewModel_PropertyChanged;
            _loginCommandInstance = _viewModel.LoginCommand; // Store command

            // Manually update View state based on initial ViewModel state
            UpdateErrorMessage(_viewModel.ErrorMessage);
            UpdateProgressVisibility(_viewModel.IsLoggingIn);
            UpdateLoginButtonState(); // Update button based on CanExecute
        }
        else
        {
            // Clear View state if ViewModel is null
            UpdateErrorMessage(null);
            UpdateProgressVisibility(false);
            UpdateLoginButtonState();
        }
    }

    // React to ViewModel property changes
    private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (_viewModel == null) return;

        // Update relevant View control based on changed ViewModel property
        switch (e.PropertyName)
        {
            case nameof(LoginViewModel.ErrorMessage):
                // Update error message display
                UpdateErrorMessage(_viewModel.ErrorMessage);
                break;

            case nameof(LoginViewModel.IsLoggingIn):
                // Update progress bar visibility and button state
                UpdateProgressVisibility(_viewModel.IsLoggingIn);
                UpdateLoginButtonState();
                break;

            case nameof(LoginViewModel.Password):
                // Update button state when password changes (affects CanExecute)
                UpdateLoginButtonState();
                break;
        }
    }

    // Update password in ViewModel when TextBox changes
    private void PasswordTextBox_TextChanged(object? sender, TextChangedEventArgs e)
    {
        if (_viewModel != null && sender is TextBox tb)
        {
            _viewModel.Password = tb.Text; // Manual two-way update
        }
    }

    // Execute command when button is clicked
    private void LoginButton_Click(object? sender, RoutedEventArgs e)
    {
        // Execute the command stored in the field if it can be executed
        if (_loginCommandInstance?.CanExecute(null) ?? false)
        {
            _loginCommandInstance.Execute(null);
        }
    }

    // --- Helper methods for updating View state ---
    private void UpdateErrorMessage(string? message)
    {
        // Set the TextBlock's text, defaulting to empty if message is null
        _errorMessageTextBlock.Text = message ?? string.Empty;
    }

    private void UpdateProgressVisibility(bool isVisible)
    {
        // Set the ProgressBar's visibility
        _progressBar.IsVisible = isVisible;
    }

    private void UpdateLoginButtonState()
    {
        // Enable/disable button based on the stored command's CanExecute result
        _loginButton.IsEnabled = _loginCommandInstance?.CanExecute(null) ?? false;
    }

    // Ensure cleanup on unload
    protected override void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnDetachedFromVisualTree(e);
        // Unsubscribe from PropertyChanged event to prevent memory leaks
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
        }
        // Clear references
        _viewModel = null;
        _loginCommandInstance = null;
    }
}
</file>

<file path="Views\MainView.cs">
using System.ComponentModel;
using System.Windows.Input;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Layout;
using Avalonia.Media;
using Avalonia.Threading;
using Avalonia.VisualTree;
using Dottle.ViewModels;

namespace Dottle.Views;

public sealed class MainView : UserControl
{
    private readonly ListBox _journalListBox;
    private readonly TextBox _editorTextBox;
    private readonly TextBlock _statusBarTextBlock;
    private readonly Button _saveButton;
    private readonly Button _newButton;
    private readonly Menu _menuBar;

    private MainViewModel? _viewModel;
    // Renamed command reference field
    private ICommand? _requestNewJournalDateCommand;
    private ICommand? _saveJournalCommand;

    private bool _isSyncingText = false;
    private ListBoxItem? _currentlySelectedListBoxItem = null;

    public MainView()
    {
        this.DataContextChanged += OnDataContextChangedHandler;

        var exportJournalsMenuItem = new MenuItem { Header = "Export Journals..." };
        exportJournalsMenuItem.Click += ExportJournalsMenuItem_Click; // Placeholder handler

        var fileMenu = new MenuItem
        {
            Header = "_File",
            Items = { exportJournalsMenuItem }
        };

        var changePasswordMenuItem = new MenuItem { Header = "Change Password..." };
        changePasswordMenuItem.Click += ChangePasswordMenuItem_Click;

        var securityMenu = new MenuItem
        {
            Header = "_Security",
            Items = { changePasswordMenuItem }
        };

        _menuBar = new Menu
        {
            Items = { fileMenu, securityMenu } // Add fileMenu here
        };
        DockPanel.SetDock(_menuBar, Dock.Top);

        _newButton = new Button
        {
            Content = "New Journal",
            HorizontalAlignment = HorizontalAlignment.Stretch,
            Margin = new Thickness(5),
            IsEnabled = false // Initial state, enabled by VM command CanExecute
        };
        DockPanel.SetDock(_newButton, Dock.Top);
        _newButton.Click += NewButton_Click; // Click handler executes the VM command

        _journalListBox = new ListBox
        {
            Background = Brushes.Transparent,
            ItemTemplate = JournalDataTemplate(),
            SelectionMode = SelectionMode.Single
        };

        var journalListScrollViewer = new ScrollViewer { Content = _journalListBox };
        var leftDockPanel = new DockPanel { Children = { _newButton, journalListScrollViewer } };
        var leftBorder = new Border
        {
            BorderBrush = SolidColorBrush.Parse("#444"),
            BorderThickness = new Thickness(0, 0, 1, 0),
            Child = leftDockPanel
        };
        Grid.SetColumn(leftBorder, 0); Grid.SetRow(leftBorder, 0);

        _saveButton = new Button
        {
            Content = "Save Journal",
            HorizontalAlignment = HorizontalAlignment.Right,
            Margin = new Thickness(5),
            IsEnabled = false
        };
        _saveButton.Classes.Add("accent");
        DockPanel.SetDock(_saveButton, Dock.Top);
        _saveButton.Click += SaveButton_Click;

        _editorTextBox = new TextBox
        {
            AcceptsReturn = true,
            AcceptsTab = true,
            TextWrapping = TextWrapping.Wrap,
            FontFamily = new FontFamily("Cascadia Mono, Consolas, Courier New, monospace"),
            FontSize = 13,
            Padding = new Thickness(5),
            VerticalAlignment = VerticalAlignment.Stretch,
            HorizontalAlignment = HorizontalAlignment.Stretch,
            IsEnabled = false,
            IsReadOnly = false
        };
        _editorTextBox.TextChanged += EditorTextBox_TextChanged;

        var rightDockPanel = new DockPanel { Children = { _saveButton, _editorTextBox } };
        Grid.SetColumn(rightDockPanel, 1); Grid.SetRow(rightDockPanel, 0);

        _statusBarTextBlock = new TextBlock
        {
            FontSize = 11,
            VerticalAlignment = VerticalAlignment.Center
        };
        var bottomBorder = new Border
        {
            Background = SolidColorBrush.Parse("#2a2a2a"),
            BorderBrush = SolidColorBrush.Parse("#444"),
            BorderThickness = new Thickness(0, 1, 0, 0),
            Padding = new Thickness(5, 3),
            Child = _statusBarTextBlock
        };
        Grid.SetColumn(bottomBorder, 0); Grid.SetRow(bottomBorder, 1); Grid.SetColumnSpan(bottomBorder, 2);

        var mainDockPanel = new DockPanel();
        mainDockPanel.Children.Add(_menuBar);

        var contentGrid = new Grid
        {
            ColumnDefinitions = new ColumnDefinitions("Auto,*"),
            RowDefinitions = new RowDefinitions("*,Auto"),
            Children = { leftBorder, rightDockPanel, bottomBorder }
        };
        mainDockPanel.Children.Add(contentGrid);

        Content = mainDockPanel;
    }

    // Get owner window reference when attached
    protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnAttachedToVisualTree(e);
        if (_viewModel != null)
        {
            // Pass owner window ref to VM for dialogs
            _viewModel.OwnerWindow = this.VisualRoot as Window;
        }
    }


    private void OnDataContextChangedHandler(object? sender, EventArgs e)
    {
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
            _viewModel.OwnerWindow = null; // Clear owner reference
        }

        _viewModel = DataContext as MainViewModel;
        // Reset command references
        _requestNewJournalDateCommand = null;
        _saveJournalCommand = null;
        _currentlySelectedListBoxItem = null;

        if (_viewModel != null)
        {
            _viewModel.PropertyChanged += ViewModel_PropertyChanged;
            // Fetch correct command reference
            _requestNewJournalDateCommand = _viewModel.RequestNewJournalDateCommand;
            _saveJournalCommand = _viewModel.SaveJournalCommand;

            // Set owner window ref on VM if we are already attached
            if (this.IsAttachedToVisualTree())
            {
                _viewModel.OwnerWindow = this.VisualRoot as Window;
            }

            UpdateJournalList(_viewModel.JournalGroups);
            UpdateEditorText(_viewModel.CurrentJournalContent);
            UpdateVisualSelection(_viewModel.SelectedJournal);
            UpdateEditorState(_viewModel.IsJournalSelected, _viewModel.IsLoadingContent);
            UpdateStatusBar(_viewModel.StatusBarText);
            UpdateNewButtonState(); // Update state based on new command
            UpdateSaveButtonState();
        }
        else
        {
            UpdateJournalList(null);
            UpdateEditorText(null);
            UpdateVisualSelection(null);
            UpdateEditorState(false, false);
            UpdateStatusBar(null);
            UpdateNewButtonState();
            UpdateSaveButtonState();
        }
    }

    private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (_viewModel == null) return;

        switch (e.PropertyName)
        {
            case nameof(MainViewModel.JournalGroups):
                UpdateJournalList(_viewModel.JournalGroups);
                UpdateVisualSelection(_viewModel.SelectedJournal);
                break;
            case nameof(MainViewModel.SelectedJournal):
                UpdateVisualSelection(_viewModel.SelectedJournal);
                UpdateEditorState(_viewModel.IsJournalSelected, _viewModel.IsLoadingContent);
                UpdateSaveButtonState();
                UpdateEditorText(_viewModel.CurrentJournalContent);
                break;
            case nameof(MainViewModel.CurrentJournalContent):
                UpdateEditorText(_viewModel.CurrentJournalContent);
                UpdateSaveButtonState();
                break;
            case nameof(MainViewModel.IsLoadingContent):
                UpdateEditorState(_viewModel.IsJournalSelected, _viewModel.IsLoadingContent);
                break;
            case nameof(MainViewModel.IsSavingContent):
                UpdateSaveButtonState();
                break;
            case nameof(MainViewModel.StatusBarText):
                UpdateStatusBar(_viewModel.StatusBarText);
                break;
            case nameof(MainViewModel.IsChangingPassword):
                break;
            case nameof(MainViewModel.ChangePasswordErrorMessage):
                if (!string.IsNullOrEmpty(_viewModel.ChangePasswordErrorMessage))
                {
                }
                break;
        }
    }

    private void EditorTextBox_TextChanged(object? sender, TextChangedEventArgs e)
    {
        if (_viewModel == null || _isSyncingText) return;

        _viewModel.CurrentJournalContent = _editorTextBox.Text;
    }

    // Executes the VM command to show the date dialog
    private void NewButton_Click(object? sender, RoutedEventArgs e)
    {
        _requestNewJournalDateCommand?.Execute(null);
    }

    private void SaveButton_Click(object? sender, RoutedEventArgs e)
    {
        _saveJournalCommand?.Execute(null);
    }

    private async void ChangePasswordMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_viewModel == null || _viewModel.OwnerWindow == null) return;

        var dialogViewModel = new ChangePasswordDialogViewModel(async (oldPass, newPass) =>
        {
            await Task.CompletedTask;
            return true;
        });

        var dialog = new ChangePasswordDialog
        {
            DataContext = dialogViewModel
        };

        var dialogResult = await dialog.ShowDialog<bool>(_viewModel.OwnerWindow);

        if (dialogResult && dialog.IsConfirmed && _viewModel != null && dialogViewModel != null)
        {
            _viewModel.CurrentPasswordForChange = dialogViewModel.OldPassword;
            _viewModel.NewPassword = dialogViewModel.NewPassword;
            _viewModel.ConfirmNewPassword = dialogViewModel.ConfirmNewPassword;

            if (_viewModel.ChangePasswordCommand.CanExecute(null))
            {
                _ = _viewModel.ChangePasswordCommand.ExecuteAsync(null);
            }
            else
            {
                UpdateStatusBar("Could not initiate password change.");
            }
        }
    }

    // Executes the VM command to show the export dialog
    private void ExportJournalsMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_viewModel?.ShowExportDialogCommand.CanExecute(null) ?? false)
        {
            _ = _viewModel.ShowExportDialogCommand.ExecuteAsync(null); // Execute async command
        }
        else
        {
            System.Diagnostics.Debug.WriteLine("Cannot execute ShowExportDialogCommand.");
            // Optionally update status bar or show a message
            // _viewModel?.UpdateStatusBar("Cannot open export dialog right now.");
        }
    }

    private void UpdateJournalList(IEnumerable<JournalGroupViewModel>? groups)
    {
        if (_currentlySelectedListBoxItem != null)
        {
            _currentlySelectedListBoxItem.IsSelected = false;
            _currentlySelectedListBoxItem = null;
        }
        _journalListBox.ItemsSource = groups; // Still binding the top-level groups
    }

    // Updated to handle nested Month Groups
    private void UpdateVisualSelection(JournalViewModel? newSelection)
    {
        // Clear previous selection highlight if any
        if (_currentlySelectedListBoxItem != null)
        {
            _currentlySelectedListBoxItem.IsSelected = false;
            _currentlySelectedListBoxItem = null;
        }

        if (newSelection == null || _journalListBox.ItemsSource == null) return;

        // Find the target ListBoxItem through the nested structure
        foreach (var yearGroup in _journalListBox.ItemsSource.OfType<JournalGroupViewModel>())
        {
            var yearGroupContainer = _journalListBox.ContainerFromItem(yearGroup) as Control;
            if (yearGroupContainer == null)
            {
                // If container not realized, try scrolling the year group into view first
                _journalListBox.ScrollIntoView(yearGroup);
                // We might need to defer the rest of the search until UI updates
                Dispatcher.UIThread.Post(() => UpdateVisualSelection(newSelection), DispatcherPriority.Background);
                return; // Exit for now, will retry after scroll
            }

            // Find the ItemsControl for MonthGroups within the YearGroup container
            var monthItemsControl = yearGroupContainer.FindDescendantOfType<ItemsControl>();
            if (monthItemsControl == null) continue; // Should not happen with the template

            // Find the specific MonthGroupViewModel that contains the newSelection
            var targetMonthGroup = yearGroup.MonthGroups.FirstOrDefault(mg => mg.Journals.Contains(newSelection));
            if (targetMonthGroup == null) continue; // Journal not in this year group

            var monthGroupContainer = monthItemsControl.ContainerFromItem(targetMonthGroup) as Control;
            if (monthGroupContainer == null)
            {
                // If month container not realized, scroll month group into view
                monthItemsControl.ScrollIntoView(targetMonthGroup);
                Dispatcher.UIThread.Post(() => UpdateVisualSelection(newSelection), DispatcherPriority.Background);
                return; // Exit for now, will retry after scroll
            }

            // Find the ItemsControl for Journals within the MonthGroup container
            var journalItemsControl = monthGroupContainer.FindDescendantOfType<ItemsControl>();
            if (journalItemsControl == null) continue; // Should not happen

            // Find the final ListBoxItem for the JournalViewModel
            var journalItemContainer = journalItemsControl.ContainerFromItem(newSelection) as ListBoxItem;
            if (journalItemContainer != null)
            {
                // Found it! Select and scroll.
                journalItemContainer.IsSelected = true;
                _currentlySelectedListBoxItem = journalItemContainer; // Track the selected item

                // Scroll the main listbox to the year, then the inner controls
                _journalListBox.ScrollIntoView(yearGroup);
                monthItemsControl.ScrollIntoView(targetMonthGroup);
                journalItemsControl.ScrollIntoView(newSelection);

                // Ensure the final item is fully visible
                Dispatcher.UIThread.Post(() => journalItemContainer.BringIntoView(), DispatcherPriority.Loaded);
                return; // Found and selected, exit the loop
            }
            else
            {
                // If journal item container not realized yet, scroll it into view
                journalItemsControl.ScrollIntoView(newSelection);
                Dispatcher.UIThread.Post(() => UpdateVisualSelection(newSelection), DispatcherPriority.Background);
                return; // Exit for now, will retry after scroll
            }
        }
    }

    private void UpdateEditorText(string? text)
    {
        if (_isSyncingText) return;

        _isSyncingText = true;
        try
        {
            var currentText = _editorTextBox.Text ?? string.Empty;
            var newText = text ?? string.Empty;
            if (currentText != newText)
            {
                _editorTextBox.Text = newText;
            }
        }
        finally
        {
            _isSyncingText = false;
        }
    }

    private void UpdateEditorState(bool isEnabled, bool isLoading)
    {
        _editorTextBox.IsEnabled = isEnabled && !isLoading;
        _editorTextBox.IsReadOnly = isLoading;
    }

    private void UpdateStatusBar(string? text)
    {
        _statusBarTextBlock.Text = text ?? string.Empty;
    }

    // Update button state based on the correct command
    private void UpdateNewButtonState()
    {
        _newButton.IsEnabled = _requestNewJournalDateCommand?.CanExecute(null) ?? false;
    }

    private void UpdateSaveButtonState()
    {
        bool canSave = _saveJournalCommand?.CanExecute(null) ?? false;
        _saveButton.IsEnabled = canSave && _editorTextBox.IsEnabled;
    }

    protected override void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnDetachedFromVisualTree(e);
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
            _viewModel.OwnerWindow = null; // Clear owner on detach
        }
        _viewModel = null;
        _requestNewJournalDateCommand = null;
        _saveJournalCommand = null;
        _currentlySelectedListBoxItem = null;
    }

    private static IDataTemplate JournalDataTemplate()
    {
        // Template for the top-level item (Year Group)
        return new FuncDataTemplate<JournalGroupViewModel>((yearVm, ns) =>
        {
            // ItemsControl for the months within this year
            var monthItemsControl = new ItemsControl
            {
                ItemsSource = yearVm.MonthGroups, // Bind to the collection of Month Groups
                ItemTemplate = MonthGroupTemplate(), // Use the new template for months
                Focusable = false // Don't let this steal focus
            };

            return new StackPanel // Container for the year header and its months
            {
                Spacing = 4,
                Margin = new Thickness(5, 8, 5, 4), // Outer margin for the year group
                Children =
                {
                    // Year Header Text
                    new TextBlock
                    {
                        Text = yearVm.DisplayName, // Use DisplayName from JournalGroupViewModel
                        FontSize = 16,
                        FontWeight = FontWeight.Bold,
                        Margin = new Thickness(0, 0, 0, 5), // Margin below year header
                        IsEnabled = false, // Not interactive
                        Cursor = Cursor.Default
                    },
                    // The list of months for this year
                    monthItemsControl
                }
            };
        }, supportsRecycling: true); // Enable recycling for performance
    }

    // New Template for the Month Group level
    private static IDataTemplate MonthGroupTemplate()
    {
        return new FuncDataTemplate<JournalMonthGroupViewModel>((monthVm, ns) =>
        {
            // ItemsControl for the journals within this month
            var journalItemsControl = new ItemsControl
            {
                ItemsSource = monthVm.Journals, // Bind to the collection of Journals
                ItemTemplate = JournalItemTemplate(), // Use the existing template for journal entries
                Focusable = false // Don't let this steal focus
            };

            return new StackPanel // Container for the month header and its journals
            {
                Spacing = 2,
                Margin = new Thickness(15, 4, 5, 4), // Indent month groups slightly
                Children =
                {
                    // Month Header Text
                    new TextBlock
                    {
                        Text = monthVm.DisplayName, // Use DisplayName from JournalMonthGroupViewModel
                        FontSize = 13,
                        FontWeight = FontWeight.SemiBold,
                        Margin = new Thickness(0, 0, 0, 3), // Margin below month header
                        IsEnabled = false, // Not interactive
                        Cursor = Cursor.Default
                    },
                    // The list of journals for this month
                    journalItemsControl
                }
            };
        }, supportsRecycling: true); // Enable recycling
    }


    // Template for the final Journal Entry item (leaf node)
    private static IDataTemplate JournalItemTemplate()
    {
        // Defines how the JournalViewModel itself is displayed within the ListBoxItem
        var textBlockTemplate = new FuncDataTemplate<JournalViewModel>((vm, ns) =>
            new TextBlock
            {
                [!TextBlock.TextProperty] = new Avalonia.Data.Binding(nameof(vm.DisplayName)), // Bind to DisplayName
                Padding = new Thickness(0),
                HorizontalAlignment = HorizontalAlignment.Stretch,
                VerticalAlignment = VerticalAlignment.Center
            }, supportsRecycling: true);

        // Creates the actual ListBoxItem container for the JournalViewModel
        return new FuncDataTemplate<JournalViewModel>((journalVm, ns) =>
        {
            var item = new ListBoxItem
            {
                DataContext = journalVm, // Set DataContext for binding and event handlers
                Content = journalVm, // Content to be displayed using ContentTemplate
                ContentTemplate = textBlockTemplate, // Use the TextBlock template above
                Padding = new Thickness(30, 3, 5, 3), // Indent journal items further under the month
                HorizontalAlignment = HorizontalAlignment.Stretch,
                VerticalAlignment = VerticalAlignment.Center,
                Cursor = new Cursor(StandardCursorType.Hand) // Indicate it's clickable
            };
            // Attach event handler to detect clicks
            item.PointerPressed += JournalItem_PointerPressed;
            return item;
        },
        supportsRecycling: true); // Enable recycling
    }

    private static void JournalItem_PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (sender is ListBoxItem { DataContext: JournalViewModel journalVm } item)
        {
            var mainView = item.FindAncestorOfType<MainView>();
            if (mainView?._viewModel != null)
            {
                if (!ReferenceEquals(mainView._viewModel.SelectedJournal, journalVm))
                {
                    mainView._viewModel.SelectedJournal = journalVm;
                }
                e.Handled = true;
            }
        }
    }
}
</file>

<file path="Views\MainWindow.axaml.cs">
using Avalonia.Controls;

namespace Dottle.Views
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
</file>

<file path="Views\NewJournalDialog.cs">
using System.ComponentModel;
using System.Windows.Input;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Layout;
using Avalonia.Media;
using Dottle.ViewModels;

namespace Dottle.Views;

public sealed class NewJournalDialog : Window
{
    private readonly DatePicker _datePicker;
    private readonly TextBlock _persianDateTextBlock;
    private readonly StackPanel _moodSelectionPanel; // Panel to hold mood selectors
    private readonly TextBlock _errorMessageTextBlock;
    private readonly Button _confirmButton;
    private readonly Button _cancelButton;

    private NewJournalDialogViewModel? _viewModel;
    private ICommand? _confirmCommandInstance;

    public bool IsConfirmed { get; private set; } = false;
    public DateTime SelectedDate { get; private set; }
    public string SelectedMood { get; private set; } = string.Empty; // Store selected mood

    public NewJournalDialog()
    {
        Title = "Create New Journal";
        Width = 380; // Slightly wider for moods
        Height = 320; // Increased height for moods
        CanResize = false;
        WindowStartupLocation = WindowStartupLocation.CenterOwner;
        SystemDecorations = SystemDecorations.Full;

        this.DataContextChanged += OnDataContextChangedHandler;

        // --- Controls ---
        _datePicker = new DatePicker
        {
            Margin = new Thickness(0, 0, 0, 10),
            HorizontalAlignment = HorizontalAlignment.Stretch
        };
        _datePicker.SelectedDateChanged += (s, e) =>
        {
            if (_viewModel != null) _viewModel.SelectedDate = _datePicker.SelectedDate;
        };

        _persianDateTextBlock = new TextBlock
        {
            HorizontalAlignment = HorizontalAlignment.Center,
            Margin = new Thickness(0, 0, 0, 10), // Adjusted margin
            FontWeight = FontWeight.SemiBold
        };

        // --- Mood Selection Panel ---
        _moodSelectionPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            Spacing = 15,
            HorizontalAlignment = HorizontalAlignment.Center,
            Margin = new Thickness(0, 0, 0, 15)
        };
        // RadioButtons will be added dynamically in OnDataContextChangedHandler

        _errorMessageTextBlock = new TextBlock
        {
            Foreground = Brushes.Red,
            HorizontalAlignment = HorizontalAlignment.Center,
            TextWrapping = TextWrapping.Wrap,
            Margin = new Thickness(0, 0, 0, 10),
            MinHeight = 20
        };

        _confirmButton = new Button { Content = "Create Journal", IsDefault = true, IsEnabled = false, HorizontalAlignment = HorizontalAlignment.Stretch };
        _confirmButton.Classes.Add("accent");
        _confirmButton.Click += ConfirmButton_Click;

        _cancelButton = new Button { Content = "Cancel", IsCancel = true, HorizontalAlignment = HorizontalAlignment.Stretch };
        _cancelButton.Click += (s, e) => CloseDialog(false);

        // --- Layout ---
        var buttonPanel = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            Spacing = 10,
            HorizontalAlignment = HorizontalAlignment.Right,
            Children = { _cancelButton, _confirmButton }
        };

        var mainPanel = new StackPanel
        {
            Margin = new Thickness(20),
            Spacing = 5,
            Children =
            {
                new TextBlock { Text = "Select Date and Mood", FontSize = 16, FontWeight = FontWeight.SemiBold, Margin = new Thickness(0,0,0,15), HorizontalAlignment = HorizontalAlignment.Center },
                _datePicker,
                _persianDateTextBlock,
                new TextBlock { Text = "Select Mood:", HorizontalAlignment= HorizontalAlignment.Center, Margin = new Thickness(0, 5, 0, 5)},
                _moodSelectionPanel, // Add mood panel here
                _errorMessageTextBlock,
                buttonPanel
            }
        };

        Content = mainPanel;
    }

    private void OnDataContextChangedHandler(object? sender, EventArgs e)
    {
        // Clear previous state and unsubscribe
        _moodSelectionPanel.Children.Clear();
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
        }

        _confirmCommandInstance = null;
        _viewModel = DataContext as NewJournalDialogViewModel;

        if (_viewModel != null)
        {
            _viewModel.PropertyChanged += ViewModel_PropertyChanged;
            _confirmCommandInstance = _viewModel.ConfirmCommand;

            // Populate Mood RadioButtons
            string? currentVmSelection = _viewModel.SelectedMoodEmoji;
            int index = 0;
            foreach (string mood in _viewModel.AvailableMoods)
            {
                var radioButton = new RadioButton
                {
                    Content = mood,
                    GroupName = "MoodGroup",
                    FontSize = 18, // Make emojis bigger
                    Tag = mood // Store the mood string in the Tag
                };
                radioButton.Checked += MoodRadioButton_Checked;
                // Set initial checked state based on ViewModel
                if (mood == currentVmSelection)
                {
                    radioButton.IsChecked = true;
                }
                _moodSelectionPanel.Children.Add(radioButton);
                index++;
            }

            // Initialize other view state from VM
            _datePicker.SelectedDate = _viewModel.SelectedDate;
            UpdatePersianDateText(_viewModel.PersianDateString);
            UpdateErrorMessage(_viewModel.ErrorMessage);
            UpdateConfirmButtonState();
        }
        else
        {
            _datePicker.SelectedDate = null;
            UpdatePersianDateText(null);
            UpdateErrorMessage(null);
            UpdateConfirmButtonState();
        }
    }

    // Update ViewModel when a mood RadioButton is checked
    private void MoodRadioButton_Checked(object? sender, RoutedEventArgs e)
    {
        if (_viewModel != null && sender is RadioButton rb && rb.IsChecked == true && rb.Tag is string mood)
        {
            _viewModel.SelectedMoodEmoji = mood;
        }
    }

    private void ViewModel_PropertyChanged(object? sender, PropertyChangedEventArgs e)
    {
        if (_viewModel == null) return;

        switch (e.PropertyName)
        {
            case nameof(NewJournalDialogViewModel.SelectedDate):
                if (_datePicker.SelectedDate != _viewModel.SelectedDate)
                {
                    _datePicker.SelectedDate = _viewModel.SelectedDate;
                }
                UpdateConfirmButtonState();
                break;
            case nameof(NewJournalDialogViewModel.PersianDateString):
                UpdatePersianDateText(_viewModel.PersianDateString);
                break;
            case nameof(NewJournalDialogViewModel.SelectedMoodEmoji):
                // Sync RadioButton state if VM changes mood (less common)
                string? vmMood = _viewModel.SelectedMoodEmoji;
                foreach (var rb in _moodSelectionPanel.Children.OfType<RadioButton>())
                {
                    if (rb.Tag is string rbMood)
                    {
                        rb.IsChecked = (rbMood == vmMood);
                    }
                }
                UpdateConfirmButtonState();
                break;
            case nameof(NewJournalDialogViewModel.ErrorMessage):
                UpdateErrorMessage(_viewModel.ErrorMessage);
                break;
        }
    }

    private void ConfirmButton_Click(object? sender, RoutedEventArgs e)
    {
        if (_confirmCommandInstance?.CanExecute(null) ?? false)
        {
            _confirmCommandInstance.Execute(null);

            if (string.IsNullOrEmpty(_viewModel?.ErrorMessage))
            {
                SelectedDate = _viewModel!.ConfirmedDate;
                SelectedMood = _viewModel!.ConfirmedMoodEmoji; // Get confirmed mood
                CloseDialog(true);
            }
        }
    }

    private void UpdatePersianDateText(string? text)
    {
        _persianDateTextBlock.Text = text ?? string.Empty;
    }

    private void UpdateErrorMessage(string? message)
    {
        _errorMessageTextBlock.Text = message ?? string.Empty;
    }

    private void UpdateConfirmButtonState()
    {
        _confirmButton.IsEnabled = _confirmCommandInstance?.CanExecute(null) ?? false;
    }

    private void CloseDialog(bool success)
    {
        IsConfirmed = success;
        Close(success);
    }

    protected override void OnClosed(EventArgs e)
    {
        base.OnClosed(e);
        if (_viewModel != null)
        {
            _viewModel.PropertyChanged -= ViewModel_PropertyChanged;
        }
        _viewModel = null;
        _confirmCommandInstance = null;
    }
}
</file>

<file path="Views\ViewBase.cs">
using Avalonia.Controls;
using Dottle.ViewModels; // Assuming ViewModels namespace

namespace Dottle.Views;

// Simple base class if needed, though often not strictly necessary
// if setting DataContext directly in constructors or App setup.
public abstract class ViewBase<TViewModel> : UserControl where TViewModel : ViewModelBase
{
    public TViewModel? ViewModel => DataContext as TViewModel;

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);
        // Can add common logic here if needed when DataContext changes
    }
}
</file>

